// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.10
// 	protoc        v5.27.1
// source: server.proto

package proto

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type GameSnapshot_State int32

const (
	// The game is waiting for all players be connected. There is a configurable time limit to wait for players. After
	// this limit expires, the match is considered over.
	GameSnapshot_WAITING GameSnapshot_State = 0
	// The game resets the players position to start the match or to restart the match after a goal.
	GameSnapshot_GET_READY GameSnapshot_State = 1
	// The game is waiting for players orders. There is a configurable time window for this phase. After the time
	// limit expires, the server will ignore the missing orders and process the ones it got.
	// (when running on dev mode, the server may allow different behaviours)
	GameSnapshot_LISTENING GameSnapshot_State = 2
	// The game is executing the players' orders in the same sequence they were gotten.
	// If the ball is NOT been holden, its velocity will be processed first. Otherwise, it position will be updated
	// when the ball holder movement be processed.
	// If there is no movement orders from a player, but it has speed greater than 0, it will be processed after
	// all its orders are processed.
	// Each player orders will be processed in the same sequence they were included in the message (e.g. first move,
	// than kick)
	// The ball kick is processed immediately after the order (the ball position is updated as its new velocity
	// after the kick)
	GameSnapshot_PLAYING GameSnapshot_State = 3
	// The game interrupt the match to shift the ball possession. It happens only when the shot time is over (see
	// shot_clock property). The ball will be given to the goalkeeper of the defense team, and the next state will
	// "listening", so the bots will not have time to rearrange before the next turn.
	GameSnapshot_SHIFTING GameSnapshot_State = 4
	// The game may be over after any phase.
	// It can be over after Waiting if there is no players connected after the time limit for connections
	// It can be over after GetReady or Listening if there is no enough players (e.g. connection lost)
	// And it also can be over after Playing state if that was the last turn of the match.
	GameSnapshot_OVER GameSnapshot_State = 99
)

// Enum value maps for GameSnapshot_State.
var (
	GameSnapshot_State_name = map[int32]string{
		0:  "WAITING",
		1:  "GET_READY",
		2:  "LISTENING",
		3:  "PLAYING",
		4:  "SHIFTING",
		99: "OVER",
	}
	GameSnapshot_State_value = map[string]int32{
		"WAITING":   0,
		"GET_READY": 1,
		"LISTENING": 2,
		"PLAYING":   3,
		"SHIFTING":  4,
		"OVER":      99,
	}
)

func (x GameSnapshot_State) Enum() *GameSnapshot_State {
	p := new(GameSnapshot_State)
	*p = x
	return p
}

func (x GameSnapshot_State) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (GameSnapshot_State) Descriptor() protoreflect.EnumDescriptor {
	return file_server_proto_enumTypes[0].Descriptor()
}

func (GameSnapshot_State) Type() protoreflect.EnumType {
	return &file_server_proto_enumTypes[0]
}

func (x GameSnapshot_State) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use GameSnapshot_State.Descriptor instead.
func (GameSnapshot_State) EnumDescriptor() ([]byte, []int) {
	return file_server_proto_rawDescGZIP(), []int{1, 0}
}

type GameSnapshot_Period int32

const (
	GameSnapshot_REGULAR_TIME GameSnapshot_Period = 0
	GameSnapshot_OVERTIME     GameSnapshot_Period = 1
	GameSnapshot_SHOOTOUT     GameSnapshot_Period = 2
)

// Enum value maps for GameSnapshot_Period.
var (
	GameSnapshot_Period_name = map[int32]string{
		0: "REGULAR_TIME",
		1: "OVERTIME",
		2: "SHOOTOUT",
	}
	GameSnapshot_Period_value = map[string]int32{
		"REGULAR_TIME": 0,
		"OVERTIME":     1,
		"SHOOTOUT":     2,
	}
)

func (x GameSnapshot_Period) Enum() *GameSnapshot_Period {
	p := new(GameSnapshot_Period)
	*p = x
	return p
}

func (x GameSnapshot_Period) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (GameSnapshot_Period) Descriptor() protoreflect.EnumDescriptor {
	return file_server_proto_enumTypes[1].Descriptor()
}

func (GameSnapshot_Period) Type() protoreflect.EnumType {
	return &file_server_proto_enumTypes[1]
}

func (x GameSnapshot_Period) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use GameSnapshot_Period.Descriptor instead.
func (GameSnapshot_Period) EnumDescriptor() ([]byte, []int) {
	return file_server_proto_rawDescGZIP(), []int{1, 1}
}

type Team_Side int32

const (
	// Team playing on the left side of field
	Team_HOME Team_Side = 0
	// Team playing on the right side of the field
	Team_AWAY Team_Side = 1
)

// Enum value maps for Team_Side.
var (
	Team_Side_name = map[int32]string{
		0: "HOME",
		1: "AWAY",
	}
	Team_Side_value = map[string]int32{
		"HOME": 0,
		"AWAY": 1,
	}
)

func (x Team_Side) Enum() *Team_Side {
	p := new(Team_Side)
	*p = x
	return p
}

func (x Team_Side) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Team_Side) Descriptor() protoreflect.EnumDescriptor {
	return file_server_proto_enumTypes[2].Descriptor()
}

func (Team_Side) Type() protoreflect.EnumType {
	return &file_server_proto_enumTypes[2]
}

func (x Team_Side) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Team_Side.Descriptor instead.
func (Team_Side) EnumDescriptor() ([]byte, []int) {
	return file_server_proto_rawDescGZIP(), []int{2, 0}
}

type OrderResponse_StatusCode int32

const (
	OrderResponse_SUCCESS        OrderResponse_StatusCode = 0
	OrderResponse_UNKNOWN_PLAYER OrderResponse_StatusCode = 1
	OrderResponse_NOT_LISTENING  OrderResponse_StatusCode = 2
	OrderResponse_WRONG_TURN     OrderResponse_StatusCode = 3
	OrderResponse_OTHER          OrderResponse_StatusCode = 99
)

// Enum value maps for OrderResponse_StatusCode.
var (
	OrderResponse_StatusCode_name = map[int32]string{
		0:  "SUCCESS",
		1:  "UNKNOWN_PLAYER",
		2:  "NOT_LISTENING",
		3:  "WRONG_TURN",
		99: "OTHER",
	}
	OrderResponse_StatusCode_value = map[string]int32{
		"SUCCESS":        0,
		"UNKNOWN_PLAYER": 1,
		"NOT_LISTENING":  2,
		"WRONG_TURN":     3,
		"OTHER":          99,
	}
)

func (x OrderResponse_StatusCode) Enum() *OrderResponse_StatusCode {
	p := new(OrderResponse_StatusCode)
	*p = x
	return p
}

func (x OrderResponse_StatusCode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (OrderResponse_StatusCode) Descriptor() protoreflect.EnumDescriptor {
	return file_server_proto_enumTypes[3].Descriptor()
}

func (OrderResponse_StatusCode) Type() protoreflect.EnumType {
	return &file_server_proto_enumTypes[3]
}

func (x OrderResponse_StatusCode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use OrderResponse_StatusCode.Descriptor instead.
func (OrderResponse_StatusCode) EnumDescriptor() ([]byte, []int) {
	return file_server_proto_rawDescGZIP(), []int{6, 0}
}

// JoinRequest define the player configuration to the game.
type JoinRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Only used in official matches to guarantee that only one process will assume that player position (team and number).
	// The bot process will receive this token as an argument, and must send it to the server in this message.
	Token string `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
	// Identifies the protocol version of the bot.
	ProtocolVersion string `protobuf:"bytes,2,opt,name=protocol_version,json=protocolVersion,proto3" json:"protocol_version,omitempty"`
	// Identify the bot's team side (Team_Home or Team_Away)
	TeamSide Team_Side `protobuf:"varint,3,opt,name=team_side,json=teamSide,proto3,enum=lugo.Team_Side" json:"team_side,omitempty"`
	// Player's number 1-11
	Number uint32 `protobuf:"varint,4,opt,name=number,proto3" json:"number,omitempty"`
	// Position where the player must be set at "GetReady" state (at beginning of the match or after a goal)
	InitPosition  *Point `protobuf:"bytes,5,opt,name=init_position,json=initPosition,proto3" json:"init_position,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *JoinRequest) Reset() {
	*x = JoinRequest{}
	mi := &file_server_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *JoinRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*JoinRequest) ProtoMessage() {}

func (x *JoinRequest) ProtoReflect() protoreflect.Message {
	mi := &file_server_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use JoinRequest.ProtoReflect.Descriptor instead.
func (*JoinRequest) Descriptor() ([]byte, []int) {
	return file_server_proto_rawDescGZIP(), []int{0}
}

func (x *JoinRequest) GetToken() string {
	if x != nil {
		return x.Token
	}
	return ""
}

func (x *JoinRequest) GetProtocolVersion() string {
	if x != nil {
		return x.ProtocolVersion
	}
	return ""
}

func (x *JoinRequest) GetTeamSide() Team_Side {
	if x != nil {
		return x.TeamSide
	}
	return Team_HOME
}

func (x *JoinRequest) GetNumber() uint32 {
	if x != nil {
		return x.Number
	}
	return 0
}

func (x *JoinRequest) GetInitPosition() *Point {
	if x != nil {
		return x.InitPosition
	}
	return nil
}

// GameSnapshot stores all game elements data.
type GameSnapshot struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The game state defines which phase the game is. The phase determine what the server is doing, are going to do, or
	// what it is waiting for.
	State GameSnapshot_State `protobuf:"varint,1,opt,name=state,proto3,enum=lugo.GameSnapshot_State" json:"state,omitempty"`
	// Turns counter. It starts from 1, but before the match starts, it may be zero.
	Turn uint32 `protobuf:"varint,2,opt,name=turn,proto3" json:"turn,omitempty"`
	// Store the home team elements.
	HomeTeam *Team `protobuf:"bytes,3,opt,name=home_team,json=homeTeam,proto3" json:"home_team,omitempty"`
	// Store the away team elements.
	AwayTeam *Team `protobuf:"bytes,4,opt,name=away_team,json=awayTeam,proto3" json:"away_team,omitempty"`
	// Store the ball element.
	Ball *Ball `protobuf:"bytes,5,opt,name=ball,proto3" json:"ball,omitempty"`
	// number of turns the ball is in a goal zone
	TurnsBallInGoalZone uint32 `protobuf:"varint,6,opt,name=turns_ball_in_goal_zone,json=turnsBallInGoalZone,proto3" json:"turns_ball_in_goal_zone,omitempty"`
	// Store the shot clock to control ball possession limit
	ShotClock     *ShotClock          `protobuf:"bytes,7,opt,name=shot_clock,json=shotClock,proto3" json:"shot_clock,omitempty"`
	Period        GameSnapshot_Period `protobuf:"varint,8,opt,name=period,proto3,enum=lugo.GameSnapshot_Period" json:"period,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GameSnapshot) Reset() {
	*x = GameSnapshot{}
	mi := &file_server_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GameSnapshot) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GameSnapshot) ProtoMessage() {}

func (x *GameSnapshot) ProtoReflect() protoreflect.Message {
	mi := &file_server_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GameSnapshot.ProtoReflect.Descriptor instead.
func (*GameSnapshot) Descriptor() ([]byte, []int) {
	return file_server_proto_rawDescGZIP(), []int{1}
}

func (x *GameSnapshot) GetState() GameSnapshot_State {
	if x != nil {
		return x.State
	}
	return GameSnapshot_WAITING
}

func (x *GameSnapshot) GetTurn() uint32 {
	if x != nil {
		return x.Turn
	}
	return 0
}

func (x *GameSnapshot) GetHomeTeam() *Team {
	if x != nil {
		return x.HomeTeam
	}
	return nil
}

func (x *GameSnapshot) GetAwayTeam() *Team {
	if x != nil {
		return x.AwayTeam
	}
	return nil
}

func (x *GameSnapshot) GetBall() *Ball {
	if x != nil {
		return x.Ball
	}
	return nil
}

func (x *GameSnapshot) GetTurnsBallInGoalZone() uint32 {
	if x != nil {
		return x.TurnsBallInGoalZone
	}
	return 0
}

func (x *GameSnapshot) GetShotClock() *ShotClock {
	if x != nil {
		return x.ShotClock
	}
	return nil
}

func (x *GameSnapshot) GetPeriod() GameSnapshot_Period {
	if x != nil {
		return x.Period
	}
	return GameSnapshot_REGULAR_TIME
}

// Stores all team elements and data.
type Team struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// List of player in the team
	Players []*Player `protobuf:"bytes,1,rep,name=players,proto3" json:"players,omitempty"`
	// Team name
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// Team score in the present turn
	Score uint32 `protobuf:"varint,3,opt,name=score,proto3" json:"score,omitempty"`
	// Side which the team is playing on.
	Side          Team_Side `protobuf:"varint,4,opt,name=side,proto3,enum=lugo.Team_Side" json:"side,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Team) Reset() {
	*x = Team{}
	mi := &file_server_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Team) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Team) ProtoMessage() {}

func (x *Team) ProtoReflect() protoreflect.Message {
	mi := &file_server_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Team.ProtoReflect.Descriptor instead.
func (*Team) Descriptor() ([]byte, []int) {
	return file_server_proto_rawDescGZIP(), []int{2}
}

func (x *Team) GetPlayers() []*Player {
	if x != nil {
		return x.Players
	}
	return nil
}

func (x *Team) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Team) GetScore() uint32 {
	if x != nil {
		return x.Score
	}
	return 0
}

func (x *Team) GetSide() Team_Side {
	if x != nil {
		return x.Side
	}
	return Team_HOME
}

// Stores the side of the team in attack and the time remaining holding the ball.
// The team side is changed as soon a bot of the defense team catch the ball.
type ShotClock struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Team side of the team in attack.
	TeamSide Team_Side `protobuf:"varint,6,opt,name=team_side,json=teamSide,proto3,enum=lugo.Team_Side" json:"team_side,omitempty"`
	// Remaining turns the attack team may hold the ball
	RemainingTurns uint32 `protobuf:"varint,7,opt,name=remaining_turns,json=remainingTurns,proto3" json:"remaining_turns,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *ShotClock) Reset() {
	*x = ShotClock{}
	mi := &file_server_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ShotClock) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ShotClock) ProtoMessage() {}

func (x *ShotClock) ProtoReflect() protoreflect.Message {
	mi := &file_server_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ShotClock.ProtoReflect.Descriptor instead.
func (*ShotClock) Descriptor() ([]byte, []int) {
	return file_server_proto_rawDescGZIP(), []int{3}
}

func (x *ShotClock) GetTeamSide() Team_Side {
	if x != nil {
		return x.TeamSide
	}
	return Team_HOME
}

func (x *ShotClock) GetRemainingTurns() uint32 {
	if x != nil {
		return x.RemainingTurns
	}
	return 0
}

// Stores all player attributes
type Player struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Number of this player in its team (1-11)
	Number uint32 `protobuf:"varint,1,opt,name=number,proto3" json:"number,omitempty"`
	// Current player position
	Position *Point `protobuf:"bytes,2,opt,name=position,proto3" json:"position,omitempty"`
	// Current player velocity
	Velocity *Velocity `protobuf:"bytes,3,opt,name=velocity,proto3" json:"velocity,omitempty"`
	// Team side which its playing in (it's used to speed up some readings since the player element will be in a list
	// of players of a team)
	TeamSide Team_Side `protobuf:"varint,4,opt,name=team_side,json=teamSide,proto3,enum=lugo.Team_Side" json:"team_side,omitempty"`
	// Default position when it's position is reset
	InitPosition *Point `protobuf:"bytes,5,opt,name=init_position,json=initPosition,proto3" json:"init_position,omitempty"`
	// indicates the the player is jumping (goalkeepers only)
	IsJumping     bool `protobuf:"varint,6,opt,name=is_jumping,json=isJumping,proto3" json:"is_jumping,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Player) Reset() {
	*x = Player{}
	mi := &file_server_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Player) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Player) ProtoMessage() {}

func (x *Player) ProtoReflect() protoreflect.Message {
	mi := &file_server_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Player.ProtoReflect.Descriptor instead.
func (*Player) Descriptor() ([]byte, []int) {
	return file_server_proto_rawDescGZIP(), []int{4}
}

func (x *Player) GetNumber() uint32 {
	if x != nil {
		return x.Number
	}
	return 0
}

func (x *Player) GetPosition() *Point {
	if x != nil {
		return x.Position
	}
	return nil
}

func (x *Player) GetVelocity() *Velocity {
	if x != nil {
		return x.Velocity
	}
	return nil
}

func (x *Player) GetTeamSide() Team_Side {
	if x != nil {
		return x.TeamSide
	}
	return Team_HOME
}

func (x *Player) GetInitPosition() *Point {
	if x != nil {
		return x.InitPosition
	}
	return nil
}

func (x *Player) GetIsJumping() bool {
	if x != nil {
		return x.IsJumping
	}
	return false
}

// Stores all ball attributes
type Ball struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Current position
	Position *Point `protobuf:"bytes,1,opt,name=position,proto3" json:"position,omitempty"`
	// Current velocity. It will be the exactly same velocity as the ball holder when a player is holding it.
	Velocity *Velocity `protobuf:"bytes,2,opt,name=velocity,proto3" json:"velocity,omitempty"`
	// Player that is currently holding the ball. Null if the ball is not holden.
	Holder        *Player `protobuf:"bytes,3,opt,name=holder,proto3" json:"holder,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Ball) Reset() {
	*x = Ball{}
	mi := &file_server_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Ball) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Ball) ProtoMessage() {}

func (x *Ball) ProtoReflect() protoreflect.Message {
	mi := &file_server_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Ball.ProtoReflect.Descriptor instead.
func (*Ball) Descriptor() ([]byte, []int) {
	return file_server_proto_rawDescGZIP(), []int{5}
}

func (x *Ball) GetPosition() *Point {
	if x != nil {
		return x.Position
	}
	return nil
}

func (x *Ball) GetVelocity() *Velocity {
	if x != nil {
		return x.Velocity
	}
	return nil
}

func (x *Ball) GetHolder() *Player {
	if x != nil {
		return x.Holder
	}
	return nil
}

// Message sent to the player as a response after sending a order set to the the server.
type OrderResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Define if the order will be correctly processed.
	Code OrderResponse_StatusCode `protobuf:"varint,1,opt,name=code,proto3,enum=lugo.OrderResponse_StatusCode" json:"code,omitempty"`
	// String message used for debugging proposes.
	Details       string `protobuf:"bytes,2,opt,name=details,proto3" json:"details,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OrderResponse) Reset() {
	*x = OrderResponse{}
	mi := &file_server_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OrderResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OrderResponse) ProtoMessage() {}

func (x *OrderResponse) ProtoReflect() protoreflect.Message {
	mi := &file_server_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OrderResponse.ProtoReflect.Descriptor instead.
func (*OrderResponse) Descriptor() ([]byte, []int) {
	return file_server_proto_rawDescGZIP(), []int{6}
}

func (x *OrderResponse) GetCode() OrderResponse_StatusCode {
	if x != nil {
		return x.Code
	}
	return OrderResponse_SUCCESS
}

func (x *OrderResponse) GetDetails() string {
	if x != nil {
		return x.Details
	}
	return ""
}

// Message containing the orders the player want to send to the server in that turn.
type OrderSet struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Turn which this order set should be processed at.
	Turn uint32 `protobuf:"varint,1,opt,name=turn,proto3" json:"turn,omitempty"`
	// List of orders in the expected order of execution
	Orders []*Order `protobuf:"bytes,2,rep,name=orders,proto3" json:"orders,omitempty"`
	// String message used for debugging proposes.
	DebugMessage  string `protobuf:"bytes,3,opt,name=debug_message,json=debugMessage,proto3" json:"debug_message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OrderSet) Reset() {
	*x = OrderSet{}
	mi := &file_server_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OrderSet) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OrderSet) ProtoMessage() {}

func (x *OrderSet) ProtoReflect() protoreflect.Message {
	mi := &file_server_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OrderSet.ProtoReflect.Descriptor instead.
func (*OrderSet) Descriptor() ([]byte, []int) {
	return file_server_proto_rawDescGZIP(), []int{7}
}

func (x *OrderSet) GetTurn() uint32 {
	if x != nil {
		return x.Turn
	}
	return 0
}

func (x *OrderSet) GetOrders() []*Order {
	if x != nil {
		return x.Orders
	}
	return nil
}

func (x *OrderSet) GetDebugMessage() string {
	if x != nil {
		return x.DebugMessage
	}
	return ""
}

// Order to the game server. To be sent by players during the Listening phase.
type Order struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Action:
	//
	//	*Order_Move
	//	*Order_Catch
	//	*Order_Kick
	//	*Order_Jump
	Action        isOrder_Action `protobuf_oneof:"action"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Order) Reset() {
	*x = Order{}
	mi := &file_server_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Order) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Order) ProtoMessage() {}

func (x *Order) ProtoReflect() protoreflect.Message {
	mi := &file_server_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Order.ProtoReflect.Descriptor instead.
func (*Order) Descriptor() ([]byte, []int) {
	return file_server_proto_rawDescGZIP(), []int{8}
}

func (x *Order) GetAction() isOrder_Action {
	if x != nil {
		return x.Action
	}
	return nil
}

func (x *Order) GetMove() *Move {
	if x != nil {
		if x, ok := x.Action.(*Order_Move); ok {
			return x.Move
		}
	}
	return nil
}

func (x *Order) GetCatch() *Catch {
	if x != nil {
		if x, ok := x.Action.(*Order_Catch); ok {
			return x.Catch
		}
	}
	return nil
}

func (x *Order) GetKick() *Kick {
	if x != nil {
		if x, ok := x.Action.(*Order_Kick); ok {
			return x.Kick
		}
	}
	return nil
}

func (x *Order) GetJump() *Jump {
	if x != nil {
		if x, ok := x.Action.(*Order_Jump); ok {
			return x.Jump
		}
	}
	return nil
}

type isOrder_Action interface {
	isOrder_Action()
}

type Order_Move struct {
	Move *Move `protobuf:"bytes,1,opt,name=move,proto3,oneof"`
}

type Order_Catch struct {
	Catch *Catch `protobuf:"bytes,2,opt,name=catch,proto3,oneof"`
}

type Order_Kick struct {
	Kick *Kick `protobuf:"bytes,3,opt,name=kick,proto3,oneof"`
}

type Order_Jump struct {
	Jump *Jump `protobuf:"bytes,4,opt,name=jump,proto3,oneof"`
}

func (*Order_Move) isOrder_Action() {}

func (*Order_Catch) isOrder_Action() {}

func (*Order_Kick) isOrder_Action() {}

func (*Order_Jump) isOrder_Action() {}

// Order to ask the server to change the player velocity (direction and speed).
// This order replaces the current player velocity, and the new velocity attribute will be immediately processed
// in that turn. There is a limit speed to the player. The server will cap the velocity if the request is higher than
// the limit.
type Move struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The nex Velocity
	Velocity      *Velocity `protobuf:"bytes,1,opt,name=velocity,proto3" json:"velocity,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Move) Reset() {
	*x = Move{}
	mi := &file_server_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Move) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Move) ProtoMessage() {}

func (x *Move) ProtoReflect() protoreflect.Message {
	mi := &file_server_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Move.ProtoReflect.Descriptor instead.
func (*Move) Descriptor() ([]byte, []int) {
	return file_server_proto_rawDescGZIP(), []int{9}
}

func (x *Move) GetVelocity() *Velocity {
	if x != nil {
		return x.Velocity
	}
	return nil
}

// Order to try to catch the ball. The player can only catch the ball when the player is touching the ball.
// Only one catching order can be executed in a turn. So, if more than one player try to catch the ball in the same
// turn, the first processed catch order will succeed, and the next ones will fail.
type Catch struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Catch) Reset() {
	*x = Catch{}
	mi := &file_server_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Catch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Catch) ProtoMessage() {}

func (x *Catch) ProtoReflect() protoreflect.Message {
	mi := &file_server_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Catch.ProtoReflect.Descriptor instead.
func (*Catch) Descriptor() ([]byte, []int) {
	return file_server_proto_rawDescGZIP(), []int{10}
}

// The kick order is only executed by the ball holder, and it is processed immediately.
// Important: The kick velocity is summed to the current ball velocity.
// The kick speed will suffer a power reduction proportionally to the player direction when the kick is not in the
// same direction of the player direction. The reduction is calculated based on the angle with the player direction
// using the formula `SpeedReducerFactor = 0.5 + (0.5 * ((180 - ang) / 180))`
// In summary, the speed will by reduced proportionally to the angle from 100% at 0 degrees until the limit of
// 50% at 180 degrees.
type Kick struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Kick velocity (it won't be necessarily the final ball velocity)
	Velocity      *Velocity `protobuf:"bytes,1,opt,name=velocity,proto3" json:"velocity,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Kick) Reset() {
	*x = Kick{}
	mi := &file_server_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Kick) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Kick) ProtoMessage() {}

func (x *Kick) ProtoReflect() protoreflect.Message {
	mi := &file_server_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Kick.ProtoReflect.Descriptor instead.
func (*Kick) Descriptor() ([]byte, []int) {
	return file_server_proto_rawDescGZIP(), []int{11}
}

func (x *Kick) GetVelocity() *Velocity {
	if x != nil {
		return x.Velocity
	}
	return nil
}

// Changes the goalkeepers velocity in a higher speed.
// The goalkeepers may move kicker than other players when they jump, however the jump movement cannot be interrupted
// after triggered. (read specs to find out the number of turns the jump lasts)
type Jump struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Goalkeeper's velocity during the jump.
	Velocity      *Velocity `protobuf:"bytes,1,opt,name=velocity,proto3" json:"velocity,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Jump) Reset() {
	*x = Jump{}
	mi := &file_server_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Jump) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Jump) ProtoMessage() {}

func (x *Jump) ProtoReflect() protoreflect.Message {
	mi := &file_server_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Jump.ProtoReflect.Descriptor instead.
func (*Jump) Descriptor() ([]byte, []int) {
	return file_server_proto_rawDescGZIP(), []int{12}
}

func (x *Jump) GetVelocity() *Velocity {
	if x != nil {
		return x.Velocity
	}
	return nil
}

var File_server_proto protoreflect.FileDescriptor

const file_server_proto_rawDesc = "" +
	"\n" +
	"\fserver.proto\x12\x04lugo\x1a\rphysics.proto\"\xc6\x01\n" +
	"\vJoinRequest\x12\x14\n" +
	"\x05token\x18\x01 \x01(\tR\x05token\x12)\n" +
	"\x10protocol_version\x18\x02 \x01(\tR\x0fprotocolVersion\x12,\n" +
	"\tteam_side\x18\x03 \x01(\x0e2\x0f.lugo.Team.SideR\bteamSide\x12\x16\n" +
	"\x06number\x18\x04 \x01(\rR\x06number\x120\n" +
	"\rinit_position\x18\x05 \x01(\v2\v.lugo.PointR\finitPosition\"\xee\x03\n" +
	"\fGameSnapshot\x12.\n" +
	"\x05state\x18\x01 \x01(\x0e2\x18.lugo.GameSnapshot.StateR\x05state\x12\x12\n" +
	"\x04turn\x18\x02 \x01(\rR\x04turn\x12'\n" +
	"\thome_team\x18\x03 \x01(\v2\n" +
	".lugo.TeamR\bhomeTeam\x12'\n" +
	"\taway_team\x18\x04 \x01(\v2\n" +
	".lugo.TeamR\bawayTeam\x12\x1e\n" +
	"\x04ball\x18\x05 \x01(\v2\n" +
	".lugo.BallR\x04ball\x124\n" +
	"\x17turns_ball_in_goal_zone\x18\x06 \x01(\rR\x13turnsBallInGoalZone\x12.\n" +
	"\n" +
	"shot_clock\x18\a \x01(\v2\x0f.lugo.ShotClockR\tshotClock\x121\n" +
	"\x06period\x18\b \x01(\x0e2\x19.lugo.GameSnapshot.PeriodR\x06period\"W\n" +
	"\x05State\x12\v\n" +
	"\aWAITING\x10\x00\x12\r\n" +
	"\tGET_READY\x10\x01\x12\r\n" +
	"\tLISTENING\x10\x02\x12\v\n" +
	"\aPLAYING\x10\x03\x12\f\n" +
	"\bSHIFTING\x10\x04\x12\b\n" +
	"\x04OVER\x10c\"6\n" +
	"\x06Period\x12\x10\n" +
	"\fREGULAR_TIME\x10\x00\x12\f\n" +
	"\bOVERTIME\x10\x01\x12\f\n" +
	"\bSHOOTOUT\x10\x02\"\x99\x01\n" +
	"\x04Team\x12&\n" +
	"\aplayers\x18\x01 \x03(\v2\f.lugo.PlayerR\aplayers\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12\x14\n" +
	"\x05score\x18\x03 \x01(\rR\x05score\x12#\n" +
	"\x04side\x18\x04 \x01(\x0e2\x0f.lugo.Team.SideR\x04side\"\x1a\n" +
	"\x04Side\x12\b\n" +
	"\x04HOME\x10\x00\x12\b\n" +
	"\x04AWAY\x10\x01\"b\n" +
	"\tShotClock\x12,\n" +
	"\tteam_side\x18\x06 \x01(\x0e2\x0f.lugo.Team.SideR\bteamSide\x12'\n" +
	"\x0fremaining_turns\x18\a \x01(\rR\x0eremainingTurns\"\xf4\x01\n" +
	"\x06Player\x12\x16\n" +
	"\x06number\x18\x01 \x01(\rR\x06number\x12'\n" +
	"\bposition\x18\x02 \x01(\v2\v.lugo.PointR\bposition\x12*\n" +
	"\bvelocity\x18\x03 \x01(\v2\x0e.lugo.VelocityR\bvelocity\x12,\n" +
	"\tteam_side\x18\x04 \x01(\x0e2\x0f.lugo.Team.SideR\bteamSide\x120\n" +
	"\rinit_position\x18\x05 \x01(\v2\v.lugo.PointR\finitPosition\x12\x1d\n" +
	"\n" +
	"is_jumping\x18\x06 \x01(\bR\tisJumping\"\x81\x01\n" +
	"\x04Ball\x12'\n" +
	"\bposition\x18\x01 \x01(\v2\v.lugo.PointR\bposition\x12*\n" +
	"\bvelocity\x18\x02 \x01(\v2\x0e.lugo.VelocityR\bvelocity\x12$\n" +
	"\x06holder\x18\x03 \x01(\v2\f.lugo.PlayerR\x06holder\"\xba\x01\n" +
	"\rOrderResponse\x122\n" +
	"\x04code\x18\x01 \x01(\x0e2\x1e.lugo.OrderResponse.StatusCodeR\x04code\x12\x18\n" +
	"\adetails\x18\x02 \x01(\tR\adetails\"[\n" +
	"\n" +
	"StatusCode\x12\v\n" +
	"\aSUCCESS\x10\x00\x12\x12\n" +
	"\x0eUNKNOWN_PLAYER\x10\x01\x12\x11\n" +
	"\rNOT_LISTENING\x10\x02\x12\x0e\n" +
	"\n" +
	"WRONG_TURN\x10\x03\x12\t\n" +
	"\x05OTHER\x10c\"h\n" +
	"\bOrderSet\x12\x12\n" +
	"\x04turn\x18\x01 \x01(\rR\x04turn\x12#\n" +
	"\x06orders\x18\x02 \x03(\v2\v.lugo.OrderR\x06orders\x12#\n" +
	"\rdebug_message\x18\x03 \x01(\tR\fdebugMessage\"\x9c\x01\n" +
	"\x05Order\x12 \n" +
	"\x04move\x18\x01 \x01(\v2\n" +
	".lugo.MoveH\x00R\x04move\x12#\n" +
	"\x05catch\x18\x02 \x01(\v2\v.lugo.CatchH\x00R\x05catch\x12 \n" +
	"\x04kick\x18\x03 \x01(\v2\n" +
	".lugo.KickH\x00R\x04kick\x12 \n" +
	"\x04jump\x18\x04 \x01(\v2\n" +
	".lugo.JumpH\x00R\x04jumpB\b\n" +
	"\x06action\"2\n" +
	"\x04Move\x12*\n" +
	"\bvelocity\x18\x01 \x01(\v2\x0e.lugo.VelocityR\bvelocity\"\a\n" +
	"\x05Catch\"2\n" +
	"\x04Kick\x12*\n" +
	"\bvelocity\x18\x01 \x01(\v2\x0e.lugo.VelocityR\bvelocity\"2\n" +
	"\x04Jump\x12*\n" +
	"\bvelocity\x18\x01 \x01(\v2\x0e.lugo.VelocityR\bvelocity2o\n" +
	"\x04Game\x124\n" +
	"\tJoinATeam\x12\x11.lugo.JoinRequest\x1a\x12.lugo.GameSnapshot0\x01\x121\n" +
	"\n" +
	"SendOrders\x12\x0e.lugo.OrderSet\x1a\x13.lugo.OrderResponseB#Z!github.com/lugobots/lugo4go/protob\x06proto3"

var (
	file_server_proto_rawDescOnce sync.Once
	file_server_proto_rawDescData []byte
)

func file_server_proto_rawDescGZIP() []byte {
	file_server_proto_rawDescOnce.Do(func() {
		file_server_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_server_proto_rawDesc), len(file_server_proto_rawDesc)))
	})
	return file_server_proto_rawDescData
}

var file_server_proto_enumTypes = make([]protoimpl.EnumInfo, 4)
var file_server_proto_msgTypes = make([]protoimpl.MessageInfo, 13)
var file_server_proto_goTypes = []any{
	(GameSnapshot_State)(0),       // 0: lugo.GameSnapshot.State
	(GameSnapshot_Period)(0),      // 1: lugo.GameSnapshot.Period
	(Team_Side)(0),                // 2: lugo.Team.Side
	(OrderResponse_StatusCode)(0), // 3: lugo.OrderResponse.StatusCode
	(*JoinRequest)(nil),           // 4: lugo.JoinRequest
	(*GameSnapshot)(nil),          // 5: lugo.GameSnapshot
	(*Team)(nil),                  // 6: lugo.Team
	(*ShotClock)(nil),             // 7: lugo.ShotClock
	(*Player)(nil),                // 8: lugo.Player
	(*Ball)(nil),                  // 9: lugo.Ball
	(*OrderResponse)(nil),         // 10: lugo.OrderResponse
	(*OrderSet)(nil),              // 11: lugo.OrderSet
	(*Order)(nil),                 // 12: lugo.Order
	(*Move)(nil),                  // 13: lugo.Move
	(*Catch)(nil),                 // 14: lugo.Catch
	(*Kick)(nil),                  // 15: lugo.Kick
	(*Jump)(nil),                  // 16: lugo.Jump
	(*Point)(nil),                 // 17: lugo.Point
	(*Velocity)(nil),              // 18: lugo.Velocity
}
var file_server_proto_depIdxs = []int32{
	2,  // 0: lugo.JoinRequest.team_side:type_name -> lugo.Team.Side
	17, // 1: lugo.JoinRequest.init_position:type_name -> lugo.Point
	0,  // 2: lugo.GameSnapshot.state:type_name -> lugo.GameSnapshot.State
	6,  // 3: lugo.GameSnapshot.home_team:type_name -> lugo.Team
	6,  // 4: lugo.GameSnapshot.away_team:type_name -> lugo.Team
	9,  // 5: lugo.GameSnapshot.ball:type_name -> lugo.Ball
	7,  // 6: lugo.GameSnapshot.shot_clock:type_name -> lugo.ShotClock
	1,  // 7: lugo.GameSnapshot.period:type_name -> lugo.GameSnapshot.Period
	8,  // 8: lugo.Team.players:type_name -> lugo.Player
	2,  // 9: lugo.Team.side:type_name -> lugo.Team.Side
	2,  // 10: lugo.ShotClock.team_side:type_name -> lugo.Team.Side
	17, // 11: lugo.Player.position:type_name -> lugo.Point
	18, // 12: lugo.Player.velocity:type_name -> lugo.Velocity
	2,  // 13: lugo.Player.team_side:type_name -> lugo.Team.Side
	17, // 14: lugo.Player.init_position:type_name -> lugo.Point
	17, // 15: lugo.Ball.position:type_name -> lugo.Point
	18, // 16: lugo.Ball.velocity:type_name -> lugo.Velocity
	8,  // 17: lugo.Ball.holder:type_name -> lugo.Player
	3,  // 18: lugo.OrderResponse.code:type_name -> lugo.OrderResponse.StatusCode
	12, // 19: lugo.OrderSet.orders:type_name -> lugo.Order
	13, // 20: lugo.Order.move:type_name -> lugo.Move
	14, // 21: lugo.Order.catch:type_name -> lugo.Catch
	15, // 22: lugo.Order.kick:type_name -> lugo.Kick
	16, // 23: lugo.Order.jump:type_name -> lugo.Jump
	18, // 24: lugo.Move.velocity:type_name -> lugo.Velocity
	18, // 25: lugo.Kick.velocity:type_name -> lugo.Velocity
	18, // 26: lugo.Jump.velocity:type_name -> lugo.Velocity
	4,  // 27: lugo.Game.JoinATeam:input_type -> lugo.JoinRequest
	11, // 28: lugo.Game.SendOrders:input_type -> lugo.OrderSet
	5,  // 29: lugo.Game.JoinATeam:output_type -> lugo.GameSnapshot
	10, // 30: lugo.Game.SendOrders:output_type -> lugo.OrderResponse
	29, // [29:31] is the sub-list for method output_type
	27, // [27:29] is the sub-list for method input_type
	27, // [27:27] is the sub-list for extension type_name
	27, // [27:27] is the sub-list for extension extendee
	0,  // [0:27] is the sub-list for field type_name
}

func init() { file_server_proto_init() }
func file_server_proto_init() {
	if File_server_proto != nil {
		return
	}
	file_physics_proto_init()
	file_server_proto_msgTypes[8].OneofWrappers = []any{
		(*Order_Move)(nil),
		(*Order_Catch)(nil),
		(*Order_Kick)(nil),
		(*Order_Jump)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_server_proto_rawDesc), len(file_server_proto_rawDesc)),
			NumEnums:      4,
			NumMessages:   13,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_server_proto_goTypes,
		DependencyIndexes: file_server_proto_depIdxs,
		EnumInfos:         file_server_proto_enumTypes,
		MessageInfos:      file_server_proto_msgTypes,
	}.Build()
	File_server_proto = out.File
	file_server_proto_goTypes = nil
	file_server_proto_depIdxs = nil
}
