// Code generated by protoc-gen-go. DO NOT EDIT.
// source: server.proto

package lugo

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type GameSnapshot_State int32

const (
	// The game is waiting for all players be connected. There is a configurable time limit to wait for players. After
	// this limit expires, the match is considered over.
	GameSnapshot_WAITING GameSnapshot_State = 0
	// The game resets the players position to start the match or to restart the match after a goal.
	GameSnapshot_GET_READY GameSnapshot_State = 1
	// The game is waiting for players orders. There is a configurable time window for this phase. After the time
	// limit expires, the server will ignore the missing orders and process the ones it got.
	// (when running on dev mode, the server may allow different behaviours)
	GameSnapshot_LISTENING GameSnapshot_State = 2
	// The game is executing the players' orders in the same sequence they were gotten.
	// If the ball is NOT been holden, its velocity will be processed first. Otherwise, it position will be updated
	// when the ball holder movement be processed.
	// If there is no movement orders from a player, but it has speed greater than 0, it will be processed after
	// all its orders are processed.
	// Each player orders will be processed in the same sequence they were included in the message (e.g. first move,
	// than kick)
	// The ball kick is processed immediately after the order (the ball position is updated as its new velocity
	// after the kick)
	GameSnapshot_PLAYING GameSnapshot_State = 3
	// The game interrupt the match to shift the ball possession. It happens only when the shot time is over (see
	// shot_clock property). The ball will be given to the goalkeeper of the defense team, and the next state will
	// "listening", so the bots will not have time to rearrange before the next turn.
	GameSnapshot_SHIFTING GameSnapshot_State = 4
	// The game may be over after any phase.
	// It can be over after Waiting if there is no players connected after the time limit for connections
	// It can be over after GetReady or Listening if there is no enough players (e.g. connection lost)
	// And it also can be over after Playing state if that was the last turn of the match.
	GameSnapshot_OVER GameSnapshot_State = 99
)

var GameSnapshot_State_name = map[int32]string{
	0:  "WAITING",
	1:  "GET_READY",
	2:  "LISTENING",
	3:  "PLAYING",
	4:  "SHIFTING",
	99: "OVER",
}

var GameSnapshot_State_value = map[string]int32{
	"WAITING":   0,
	"GET_READY": 1,
	"LISTENING": 2,
	"PLAYING":   3,
	"SHIFTING":  4,
	"OVER":      99,
}

func (x GameSnapshot_State) String() string {
	return proto.EnumName(GameSnapshot_State_name, int32(x))
}

func (GameSnapshot_State) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{1, 0}
}

type Team_Side int32

const (
	// Team playing on the left side of field
	Team_HOME Team_Side = 0
	// Team playing on the right side of the field
	Team_AWAY Team_Side = 1
)

var Team_Side_name = map[int32]string{
	0: "HOME",
	1: "AWAY",
}

var Team_Side_value = map[string]int32{
	"HOME": 0,
	"AWAY": 1,
}

func (x Team_Side) String() string {
	return proto.EnumName(Team_Side_name, int32(x))
}

func (Team_Side) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{2, 0}
}

type OrderResponse_StatusCode int32

const (
	OrderResponse_SUCCESS        OrderResponse_StatusCode = 0
	OrderResponse_UNKNOWN_PLAYER OrderResponse_StatusCode = 1
	OrderResponse_NOT_LISTENING  OrderResponse_StatusCode = 2
	OrderResponse_WRONG_TURN     OrderResponse_StatusCode = 3
	OrderResponse_OTHER          OrderResponse_StatusCode = 99
)

var OrderResponse_StatusCode_name = map[int32]string{
	0:  "SUCCESS",
	1:  "UNKNOWN_PLAYER",
	2:  "NOT_LISTENING",
	3:  "WRONG_TURN",
	99: "OTHER",
}

var OrderResponse_StatusCode_value = map[string]int32{
	"SUCCESS":        0,
	"UNKNOWN_PLAYER": 1,
	"NOT_LISTENING":  2,
	"WRONG_TURN":     3,
	"OTHER":          99,
}

func (x OrderResponse_StatusCode) String() string {
	return proto.EnumName(OrderResponse_StatusCode_name, int32(x))
}

func (OrderResponse_StatusCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{6, 0}
}

// JoinRequest define the player configuration to the game.
type JoinRequest struct {
	// Only used in official matches to guarantee that only one process will assume that player position (team and number).
	// The bot process will receive this token as an argument, and must send it to the server in this message.
	Token string `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
	// Identifies the protocol version of the bot.
	ProtocolVersion string `protobuf:"bytes,2,opt,name=protocol_version,json=protocolVersion,proto3" json:"protocol_version,omitempty"`
	// Identify the bot's team side (Team_Home or Team_Away)
	TeamSide Team_Side `protobuf:"varint,3,opt,name=team_side,json=teamSide,proto3,enum=lugo.Team_Side" json:"team_side,omitempty"`
	// Player's number 1-11
	Number uint32 `protobuf:"varint,4,opt,name=number,proto3" json:"number,omitempty"`
	// Position where the player must be set at "GetReady" state (at beginning of the match or after a goal)
	InitPosition         *Point   `protobuf:"bytes,5,opt,name=init_position,json=initPosition,proto3" json:"init_position,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *JoinRequest) Reset()         { *m = JoinRequest{} }
func (m *JoinRequest) String() string { return proto.CompactTextString(m) }
func (*JoinRequest) ProtoMessage()    {}
func (*JoinRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{0}
}

func (m *JoinRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_JoinRequest.Unmarshal(m, b)
}
func (m *JoinRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_JoinRequest.Marshal(b, m, deterministic)
}
func (m *JoinRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JoinRequest.Merge(m, src)
}
func (m *JoinRequest) XXX_Size() int {
	return xxx_messageInfo_JoinRequest.Size(m)
}
func (m *JoinRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_JoinRequest.DiscardUnknown(m)
}

var xxx_messageInfo_JoinRequest proto.InternalMessageInfo

func (m *JoinRequest) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *JoinRequest) GetProtocolVersion() string {
	if m != nil {
		return m.ProtocolVersion
	}
	return ""
}

func (m *JoinRequest) GetTeamSide() Team_Side {
	if m != nil {
		return m.TeamSide
	}
	return Team_HOME
}

func (m *JoinRequest) GetNumber() uint32 {
	if m != nil {
		return m.Number
	}
	return 0
}

func (m *JoinRequest) GetInitPosition() *Point {
	if m != nil {
		return m.InitPosition
	}
	return nil
}

// GameSnapshot stores all game elements data.
type GameSnapshot struct {
	// The game state defines which phase the game is. The phase determine what the server is doing, are going to do, or
	// what it is waiting for.
	State GameSnapshot_State `protobuf:"varint,1,opt,name=state,proto3,enum=lugo.GameSnapshot_State" json:"state,omitempty"`
	// Turns counter. It starts from 1, but before the match starts, it may be zero.
	Turn uint32 `protobuf:"varint,2,opt,name=turn,proto3" json:"turn,omitempty"`
	// Store the home team elements.
	HomeTeam *Team `protobuf:"bytes,3,opt,name=home_team,json=homeTeam,proto3" json:"home_team,omitempty"`
	// Store the away team elements.
	AwayTeam *Team `protobuf:"bytes,4,opt,name=away_team,json=awayTeam,proto3" json:"away_team,omitempty"`
	// Store the ball element.
	Ball                 *Ball      `protobuf:"bytes,5,opt,name=ball,proto3" json:"ball,omitempty"`
	ShotClock            *ShotClock `protobuf:"bytes,6,opt,name=shot_clock,json=shotClock,proto3" json:"shot_clock,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *GameSnapshot) Reset()         { *m = GameSnapshot{} }
func (m *GameSnapshot) String() string { return proto.CompactTextString(m) }
func (*GameSnapshot) ProtoMessage()    {}
func (*GameSnapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{1}
}

func (m *GameSnapshot) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GameSnapshot.Unmarshal(m, b)
}
func (m *GameSnapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GameSnapshot.Marshal(b, m, deterministic)
}
func (m *GameSnapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GameSnapshot.Merge(m, src)
}
func (m *GameSnapshot) XXX_Size() int {
	return xxx_messageInfo_GameSnapshot.Size(m)
}
func (m *GameSnapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_GameSnapshot.DiscardUnknown(m)
}

var xxx_messageInfo_GameSnapshot proto.InternalMessageInfo

func (m *GameSnapshot) GetState() GameSnapshot_State {
	if m != nil {
		return m.State
	}
	return GameSnapshot_WAITING
}

func (m *GameSnapshot) GetTurn() uint32 {
	if m != nil {
		return m.Turn
	}
	return 0
}

func (m *GameSnapshot) GetHomeTeam() *Team {
	if m != nil {
		return m.HomeTeam
	}
	return nil
}

func (m *GameSnapshot) GetAwayTeam() *Team {
	if m != nil {
		return m.AwayTeam
	}
	return nil
}

func (m *GameSnapshot) GetBall() *Ball {
	if m != nil {
		return m.Ball
	}
	return nil
}

func (m *GameSnapshot) GetShotClock() *ShotClock {
	if m != nil {
		return m.ShotClock
	}
	return nil
}

// Stores all team elements and data.
type Team struct {
	// List of player in the team
	Players []*Player `protobuf:"bytes,1,rep,name=players,proto3" json:"players,omitempty"`
	// Team name
	Name string `protobuf:"bytes,2,opt,name=Name,proto3" json:"Name,omitempty"`
	// Team score in the present turn
	Score uint32 `protobuf:"varint,3,opt,name=Score,proto3" json:"Score,omitempty"`
	// Side which the team is playing on.
	Side                 Team_Side `protobuf:"varint,4,opt,name=side,proto3,enum=lugo.Team_Side" json:"side,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *Team) Reset()         { *m = Team{} }
func (m *Team) String() string { return proto.CompactTextString(m) }
func (*Team) ProtoMessage()    {}
func (*Team) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{2}
}

func (m *Team) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Team.Unmarshal(m, b)
}
func (m *Team) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Team.Marshal(b, m, deterministic)
}
func (m *Team) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Team.Merge(m, src)
}
func (m *Team) XXX_Size() int {
	return xxx_messageInfo_Team.Size(m)
}
func (m *Team) XXX_DiscardUnknown() {
	xxx_messageInfo_Team.DiscardUnknown(m)
}

var xxx_messageInfo_Team proto.InternalMessageInfo

func (m *Team) GetPlayers() []*Player {
	if m != nil {
		return m.Players
	}
	return nil
}

func (m *Team) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Team) GetScore() uint32 {
	if m != nil {
		return m.Score
	}
	return 0
}

func (m *Team) GetSide() Team_Side {
	if m != nil {
		return m.Side
	}
	return Team_HOME
}

// Stores the side of the team in attack and the time remaining holding the ball.
// The team side is changed as soon a bot of the defense team catch the ball.
type ShotClock struct {
	// Team side of the team in attack.
	TeamSide Team_Side `protobuf:"varint,6,opt,name=team_side,json=teamSide,proto3,enum=lugo.Team_Side" json:"team_side,omitempty"`
	// Remaining turns the attack team may hold the ball
	Turns                uint32   `protobuf:"varint,7,opt,name=turns,proto3" json:"turns,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ShotClock) Reset()         { *m = ShotClock{} }
func (m *ShotClock) String() string { return proto.CompactTextString(m) }
func (*ShotClock) ProtoMessage()    {}
func (*ShotClock) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{3}
}

func (m *ShotClock) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ShotClock.Unmarshal(m, b)
}
func (m *ShotClock) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ShotClock.Marshal(b, m, deterministic)
}
func (m *ShotClock) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShotClock.Merge(m, src)
}
func (m *ShotClock) XXX_Size() int {
	return xxx_messageInfo_ShotClock.Size(m)
}
func (m *ShotClock) XXX_DiscardUnknown() {
	xxx_messageInfo_ShotClock.DiscardUnknown(m)
}

var xxx_messageInfo_ShotClock proto.InternalMessageInfo

func (m *ShotClock) GetTeamSide() Team_Side {
	if m != nil {
		return m.TeamSide
	}
	return Team_HOME
}

func (m *ShotClock) GetTurns() uint32 {
	if m != nil {
		return m.Turns
	}
	return 0
}

// Stores all player attributes
type Player struct {
	// Number of this player in its team (1-11)
	Number uint32 `protobuf:"varint,1,opt,name=number,proto3" json:"number,omitempty"`
	// Current player position
	Position *Point `protobuf:"bytes,2,opt,name=Position,proto3" json:"Position,omitempty"`
	// Current player velocity
	Velocity *Velocity `protobuf:"bytes,3,opt,name=velocity,proto3" json:"velocity,omitempty"`
	// Team side which its playing in (it's used to speed up some readings since the player element will be in a list
	// of players of a team)
	TeamSide Team_Side `protobuf:"varint,4,opt,name=team_side,json=teamSide,proto3,enum=lugo.Team_Side" json:"team_side,omitempty"`
	// Default position when it's position is reset
	InitPosition         *Point   `protobuf:"bytes,5,opt,name=init_position,json=initPosition,proto3" json:"init_position,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Player) Reset()         { *m = Player{} }
func (m *Player) String() string { return proto.CompactTextString(m) }
func (*Player) ProtoMessage()    {}
func (*Player) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{4}
}

func (m *Player) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Player.Unmarshal(m, b)
}
func (m *Player) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Player.Marshal(b, m, deterministic)
}
func (m *Player) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Player.Merge(m, src)
}
func (m *Player) XXX_Size() int {
	return xxx_messageInfo_Player.Size(m)
}
func (m *Player) XXX_DiscardUnknown() {
	xxx_messageInfo_Player.DiscardUnknown(m)
}

var xxx_messageInfo_Player proto.InternalMessageInfo

func (m *Player) GetNumber() uint32 {
	if m != nil {
		return m.Number
	}
	return 0
}

func (m *Player) GetPosition() *Point {
	if m != nil {
		return m.Position
	}
	return nil
}

func (m *Player) GetVelocity() *Velocity {
	if m != nil {
		return m.Velocity
	}
	return nil
}

func (m *Player) GetTeamSide() Team_Side {
	if m != nil {
		return m.TeamSide
	}
	return Team_HOME
}

func (m *Player) GetInitPosition() *Point {
	if m != nil {
		return m.InitPosition
	}
	return nil
}

// Stores all ball attributes
type Ball struct {
	// Current position
	Position *Point `protobuf:"bytes,1,opt,name=Position,proto3" json:"Position,omitempty"`
	// Current velocity. It will be the exactly same velocity as the ball holder when a player is holding it.
	Velocity *Velocity `protobuf:"bytes,2,opt,name=velocity,proto3" json:"velocity,omitempty"`
	// Player that is currently holding the ball. Null if the ball is not holden.
	Holder               *Player  `protobuf:"bytes,3,opt,name=holder,proto3" json:"holder,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Ball) Reset()         { *m = Ball{} }
func (m *Ball) String() string { return proto.CompactTextString(m) }
func (*Ball) ProtoMessage()    {}
func (*Ball) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{5}
}

func (m *Ball) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Ball.Unmarshal(m, b)
}
func (m *Ball) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Ball.Marshal(b, m, deterministic)
}
func (m *Ball) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Ball.Merge(m, src)
}
func (m *Ball) XXX_Size() int {
	return xxx_messageInfo_Ball.Size(m)
}
func (m *Ball) XXX_DiscardUnknown() {
	xxx_messageInfo_Ball.DiscardUnknown(m)
}

var xxx_messageInfo_Ball proto.InternalMessageInfo

func (m *Ball) GetPosition() *Point {
	if m != nil {
		return m.Position
	}
	return nil
}

func (m *Ball) GetVelocity() *Velocity {
	if m != nil {
		return m.Velocity
	}
	return nil
}

func (m *Ball) GetHolder() *Player {
	if m != nil {
		return m.Holder
	}
	return nil
}

// Message sent to the player as a response after sending a order set to the the server.
type OrderResponse struct {
	// Define if the order will be correctly processed.
	Code OrderResponse_StatusCode `protobuf:"varint,1,opt,name=code,proto3,enum=lugo.OrderResponse_StatusCode" json:"code,omitempty"`
	// String message used for debugging proposes.
	Details              string   `protobuf:"bytes,2,opt,name=details,proto3" json:"details,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OrderResponse) Reset()         { *m = OrderResponse{} }
func (m *OrderResponse) String() string { return proto.CompactTextString(m) }
func (*OrderResponse) ProtoMessage()    {}
func (*OrderResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{6}
}

func (m *OrderResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_OrderResponse.Unmarshal(m, b)
}
func (m *OrderResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_OrderResponse.Marshal(b, m, deterministic)
}
func (m *OrderResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderResponse.Merge(m, src)
}
func (m *OrderResponse) XXX_Size() int {
	return xxx_messageInfo_OrderResponse.Size(m)
}
func (m *OrderResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderResponse.DiscardUnknown(m)
}

var xxx_messageInfo_OrderResponse proto.InternalMessageInfo

func (m *OrderResponse) GetCode() OrderResponse_StatusCode {
	if m != nil {
		return m.Code
	}
	return OrderResponse_SUCCESS
}

func (m *OrderResponse) GetDetails() string {
	if m != nil {
		return m.Details
	}
	return ""
}

// Message containing the orders the player want to send to the server in that turn.
type OrderSet struct {
	// Turn which this order set should be processed at.
	Turn uint32 `protobuf:"varint,1,opt,name=turn,proto3" json:"turn,omitempty"`
	// List of orders in the expected order of execution
	Orders []*Order `protobuf:"bytes,2,rep,name=orders,proto3" json:"orders,omitempty"`
	// String message used for debugging proposes.
	DebugMessage         string   `protobuf:"bytes,3,opt,name=debug_message,json=debugMessage,proto3" json:"debug_message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OrderSet) Reset()         { *m = OrderSet{} }
func (m *OrderSet) String() string { return proto.CompactTextString(m) }
func (*OrderSet) ProtoMessage()    {}
func (*OrderSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{7}
}

func (m *OrderSet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_OrderSet.Unmarshal(m, b)
}
func (m *OrderSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_OrderSet.Marshal(b, m, deterministic)
}
func (m *OrderSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderSet.Merge(m, src)
}
func (m *OrderSet) XXX_Size() int {
	return xxx_messageInfo_OrderSet.Size(m)
}
func (m *OrderSet) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderSet.DiscardUnknown(m)
}

var xxx_messageInfo_OrderSet proto.InternalMessageInfo

func (m *OrderSet) GetTurn() uint32 {
	if m != nil {
		return m.Turn
	}
	return 0
}

func (m *OrderSet) GetOrders() []*Order {
	if m != nil {
		return m.Orders
	}
	return nil
}

func (m *OrderSet) GetDebugMessage() string {
	if m != nil {
		return m.DebugMessage
	}
	return ""
}

// Order to the game server. To be sent by players during the Listening phase.
type Order struct {
	// Types that are valid to be assigned to Action:
	//	*Order_Move
	//	*Order_Catch
	//	*Order_Kick
	//	*Order_Jump
	Action               isOrder_Action `protobuf_oneof:"action"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *Order) Reset()         { *m = Order{} }
func (m *Order) String() string { return proto.CompactTextString(m) }
func (*Order) ProtoMessage()    {}
func (*Order) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{8}
}

func (m *Order) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Order.Unmarshal(m, b)
}
func (m *Order) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Order.Marshal(b, m, deterministic)
}
func (m *Order) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Order.Merge(m, src)
}
func (m *Order) XXX_Size() int {
	return xxx_messageInfo_Order.Size(m)
}
func (m *Order) XXX_DiscardUnknown() {
	xxx_messageInfo_Order.DiscardUnknown(m)
}

var xxx_messageInfo_Order proto.InternalMessageInfo

type isOrder_Action interface {
	isOrder_Action()
}

type Order_Move struct {
	Move *Move `protobuf:"bytes,1,opt,name=move,proto3,oneof"`
}

type Order_Catch struct {
	Catch *Catch `protobuf:"bytes,2,opt,name=catch,proto3,oneof"`
}

type Order_Kick struct {
	Kick *Kick `protobuf:"bytes,3,opt,name=kick,proto3,oneof"`
}

type Order_Jump struct {
	Jump *Jump `protobuf:"bytes,4,opt,name=jump,proto3,oneof"`
}

func (*Order_Move) isOrder_Action() {}

func (*Order_Catch) isOrder_Action() {}

func (*Order_Kick) isOrder_Action() {}

func (*Order_Jump) isOrder_Action() {}

func (m *Order) GetAction() isOrder_Action {
	if m != nil {
		return m.Action
	}
	return nil
}

func (m *Order) GetMove() *Move {
	if x, ok := m.GetAction().(*Order_Move); ok {
		return x.Move
	}
	return nil
}

func (m *Order) GetCatch() *Catch {
	if x, ok := m.GetAction().(*Order_Catch); ok {
		return x.Catch
	}
	return nil
}

func (m *Order) GetKick() *Kick {
	if x, ok := m.GetAction().(*Order_Kick); ok {
		return x.Kick
	}
	return nil
}

func (m *Order) GetJump() *Jump {
	if x, ok := m.GetAction().(*Order_Jump); ok {
		return x.Jump
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Order) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Order_Move)(nil),
		(*Order_Catch)(nil),
		(*Order_Kick)(nil),
		(*Order_Jump)(nil),
	}
}

// Order to ask the server to change the player velocity (direction and speed).
// This order replaces the current player velocity, and the new velocity attribute will be immediately processed
// in that turn. There is a limit speed to the player. The server will cap the velocity if the request is higher than
// the limit.
type Move struct {
	// The nex Velocity
	Velocity             *Velocity `protobuf:"bytes,1,opt,name=velocity,proto3" json:"velocity,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *Move) Reset()         { *m = Move{} }
func (m *Move) String() string { return proto.CompactTextString(m) }
func (*Move) ProtoMessage()    {}
func (*Move) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{9}
}

func (m *Move) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Move.Unmarshal(m, b)
}
func (m *Move) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Move.Marshal(b, m, deterministic)
}
func (m *Move) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Move.Merge(m, src)
}
func (m *Move) XXX_Size() int {
	return xxx_messageInfo_Move.Size(m)
}
func (m *Move) XXX_DiscardUnknown() {
	xxx_messageInfo_Move.DiscardUnknown(m)
}

var xxx_messageInfo_Move proto.InternalMessageInfo

func (m *Move) GetVelocity() *Velocity {
	if m != nil {
		return m.Velocity
	}
	return nil
}

// Order to try to catch the ball. The player can only catch the ball when the player is touching the ball.
// Only one catching order can be executed in a turn. So, if more than one player try to catch the ball in the same
// turn, the first processed catch order will succeed, and the next ones will fail.
type Catch struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Catch) Reset()         { *m = Catch{} }
func (m *Catch) String() string { return proto.CompactTextString(m) }
func (*Catch) ProtoMessage()    {}
func (*Catch) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{10}
}

func (m *Catch) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Catch.Unmarshal(m, b)
}
func (m *Catch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Catch.Marshal(b, m, deterministic)
}
func (m *Catch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Catch.Merge(m, src)
}
func (m *Catch) XXX_Size() int {
	return xxx_messageInfo_Catch.Size(m)
}
func (m *Catch) XXX_DiscardUnknown() {
	xxx_messageInfo_Catch.DiscardUnknown(m)
}

var xxx_messageInfo_Catch proto.InternalMessageInfo

// The kick order is only executed by the ball holder, and it is processed immediately.
// Important: The kick velocity is summed to the current ball velocity.
// The kick speed will suffer a power reduction proportionally to the player direction when the kick is not in the
// same direction of the player direction. The reduction is calculated based on the angle with the player direction
// using the formula `SpeedReducerFactor = 0.5 + (0.5 * ((180 - ang) / 180))`
// In summary, the speed will by reduced proportionally to the angle from 100% at 0 degrees until the limit of
// 50% at 180 degrees.
type Kick struct {
	// Kick velocity (it won't be necessarily the final ball velocity)
	Velocity             *Velocity `protobuf:"bytes,1,opt,name=velocity,proto3" json:"velocity,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *Kick) Reset()         { *m = Kick{} }
func (m *Kick) String() string { return proto.CompactTextString(m) }
func (*Kick) ProtoMessage()    {}
func (*Kick) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{11}
}

func (m *Kick) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Kick.Unmarshal(m, b)
}
func (m *Kick) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Kick.Marshal(b, m, deterministic)
}
func (m *Kick) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Kick.Merge(m, src)
}
func (m *Kick) XXX_Size() int {
	return xxx_messageInfo_Kick.Size(m)
}
func (m *Kick) XXX_DiscardUnknown() {
	xxx_messageInfo_Kick.DiscardUnknown(m)
}

var xxx_messageInfo_Kick proto.InternalMessageInfo

func (m *Kick) GetVelocity() *Velocity {
	if m != nil {
		return m.Velocity
	}
	return nil
}

// Changes the goalkeepers velocity in a higher speed.
// The goalkeepers may move kicker than other players when they jump, however the jump movement cannot be interrupted
// after triggered. (read specs to find out the number of turns the jump lasts)
type Jump struct {
	// Goalkeeper's velocity during the jump.
	Velocity             *Velocity `protobuf:"bytes,1,opt,name=velocity,proto3" json:"velocity,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *Jump) Reset()         { *m = Jump{} }
func (m *Jump) String() string { return proto.CompactTextString(m) }
func (*Jump) ProtoMessage()    {}
func (*Jump) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{12}
}

func (m *Jump) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Jump.Unmarshal(m, b)
}
func (m *Jump) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Jump.Marshal(b, m, deterministic)
}
func (m *Jump) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Jump.Merge(m, src)
}
func (m *Jump) XXX_Size() int {
	return xxx_messageInfo_Jump.Size(m)
}
func (m *Jump) XXX_DiscardUnknown() {
	xxx_messageInfo_Jump.DiscardUnknown(m)
}

var xxx_messageInfo_Jump proto.InternalMessageInfo

func (m *Jump) GetVelocity() *Velocity {
	if m != nil {
		return m.Velocity
	}
	return nil
}

func init() {
	proto.RegisterEnum("lugo.GameSnapshot_State", GameSnapshot_State_name, GameSnapshot_State_value)
	proto.RegisterEnum("lugo.Team_Side", Team_Side_name, Team_Side_value)
	proto.RegisterEnum("lugo.OrderResponse_StatusCode", OrderResponse_StatusCode_name, OrderResponse_StatusCode_value)
	proto.RegisterType((*JoinRequest)(nil), "lugo.JoinRequest")
	proto.RegisterType((*GameSnapshot)(nil), "lugo.GameSnapshot")
	proto.RegisterType((*Team)(nil), "lugo.Team")
	proto.RegisterType((*ShotClock)(nil), "lugo.ShotClock")
	proto.RegisterType((*Player)(nil), "lugo.Player")
	proto.RegisterType((*Ball)(nil), "lugo.Ball")
	proto.RegisterType((*OrderResponse)(nil), "lugo.OrderResponse")
	proto.RegisterType((*OrderSet)(nil), "lugo.OrderSet")
	proto.RegisterType((*Order)(nil), "lugo.Order")
	proto.RegisterType((*Move)(nil), "lugo.Move")
	proto.RegisterType((*Catch)(nil), "lugo.Catch")
	proto.RegisterType((*Kick)(nil), "lugo.Kick")
	proto.RegisterType((*Jump)(nil), "lugo.Jump")
}

func init() {
	proto.RegisterFile("server.proto", fileDescriptor_ad098daeda4239f7)
}

var fileDescriptor_ad098daeda4239f7 = []byte{
	// 888 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x55, 0xdd, 0x6e, 0xe3, 0x44,
	0x14, 0xce, 0x34, 0x93, 0xbf, 0x93, 0x9f, 0xcd, 0x0e, 0x08, 0x45, 0xbd, 0x58, 0x45, 0x2e, 0x62,
	0x03, 0x42, 0xd1, 0x12, 0x78, 0x81, 0x6c, 0x08, 0x4d, 0x77, 0xb7, 0x71, 0x35, 0x4e, 0x1b, 0x55,
	0x5c, 0x58, 0xae, 0x33, 0x6a, 0x4c, 0x6c, 0x4f, 0xf0, 0xd8, 0x41, 0xbd, 0xe4, 0x31, 0x90, 0x78,
	0x12, 0x1e, 0x80, 0x3b, 0x2e, 0x79, 0x1f, 0x74, 0x66, 0x9c, 0x36, 0x66, 0x2b, 0x4a, 0xef, 0xe6,
	0x9c, 0xef, 0x3b, 0xf6, 0x77, 0x66, 0xbe, 0x39, 0x03, 0x2d, 0x25, 0x92, 0x9d, 0x48, 0x86, 0xdb,
	0x44, 0xa6, 0x92, 0xd1, 0x30, 0xbb, 0x95, 0xc7, 0xed, 0xed, 0xfa, 0x4e, 0x05, 0xbe, 0x32, 0x49,
	0xeb, 0x4f, 0x02, 0xcd, 0x77, 0x32, 0x88, 0xb9, 0xf8, 0x39, 0x13, 0x2a, 0x65, 0x9f, 0x42, 0x25,
	0x95, 0x1b, 0x11, 0xf7, 0x48, 0x9f, 0x0c, 0x1a, 0xdc, 0x04, 0xec, 0x4b, 0xe8, 0x6a, 0xba, 0x2f,
	0x43, 0x77, 0x27, 0x12, 0x15, 0xc8, 0xb8, 0x77, 0xa4, 0x09, 0x2f, 0xf6, 0xf9, 0x2b, 0x93, 0x66,
	0x5f, 0x43, 0x23, 0x15, 0x5e, 0xe4, 0xaa, 0x60, 0x25, 0x7a, 0xe5, 0x3e, 0x19, 0x74, 0x46, 0x2f,
	0x86, 0xf8, 0xe7, 0xe1, 0x42, 0x78, 0xd1, 0xd0, 0x09, 0x56, 0x82, 0xd7, 0x91, 0x81, 0x2b, 0xf6,
	0x19, 0x54, 0xe3, 0x2c, 0xba, 0x11, 0x49, 0x8f, 0xf6, 0xc9, 0xa0, 0xcd, 0xf3, 0x88, 0xbd, 0x81,
	0x76, 0x10, 0x07, 0xa9, 0xbb, 0x95, 0x2a, 0x48, 0xf1, 0x6f, 0x95, 0x3e, 0x19, 0x34, 0x47, 0x4d,
	0xf3, 0xa5, 0x0b, 0x19, 0xc4, 0x29, 0x6f, 0x21, 0xe3, 0x22, 0x27, 0x58, 0x7f, 0x1d, 0x41, 0xeb,
	0xd4, 0x8b, 0x84, 0x13, 0x7b, 0x5b, 0xb5, 0x96, 0x29, 0x1b, 0x42, 0x45, 0xa5, 0x5e, 0x2a, 0x74,
	0x27, 0x9d, 0x51, 0xcf, 0x94, 0x1e, 0x52, 0x86, 0x0e, 0xe2, 0xdc, 0xd0, 0x18, 0x03, 0x9a, 0x66,
	0x89, 0xe9, 0xab, 0xcd, 0xf5, 0x9a, 0xbd, 0x86, 0xc6, 0x5a, 0x46, 0xc2, 0x45, 0xbd, 0xba, 0x99,
	0xe6, 0x08, 0x1e, 0x9a, 0xe1, 0x75, 0x04, 0x71, 0x85, 0x44, 0xef, 0x17, 0xef, 0xce, 0x10, 0xe9,
	0xc7, 0x44, 0x04, 0x35, 0xf1, 0x15, 0xd0, 0x1b, 0x2f, 0x0c, 0xf3, 0x7e, 0x72, 0xce, 0x5b, 0x2f,
	0x0c, 0xb9, 0xce, 0xb3, 0x21, 0x00, 0x4a, 0x73, 0xfd, 0x50, 0xfa, 0x9b, 0x5e, 0x55, 0xb3, 0xf2,
	0xfd, 0x73, 0xd6, 0x32, 0x9d, 0x60, 0x9a, 0x37, 0xd4, 0x7e, 0x69, 0x2d, 0xa1, 0xa2, 0xbb, 0x60,
	0x4d, 0xa8, 0x2d, 0xc7, 0x67, 0x8b, 0xb3, 0xf9, 0x69, 0xb7, 0xc4, 0xda, 0xd0, 0x38, 0x9d, 0x2e,
	0x5c, 0x3e, 0x1d, 0x7f, 0x7f, 0xdd, 0x25, 0x18, 0x7e, 0x38, 0x73, 0x16, 0xd3, 0x39, 0xa2, 0x47,
	0x48, 0xbd, 0xf8, 0x30, 0xbe, 0xc6, 0xa0, 0xcc, 0x5a, 0x50, 0x77, 0x66, 0x67, 0x3f, 0xe8, 0x42,
	0xca, 0xea, 0x40, 0xed, 0xab, 0x29, 0xef, 0xfa, 0xd6, 0x6f, 0x04, 0xa8, 0x56, 0xfc, 0x05, 0xd4,
	0xb6, 0xa1, 0x77, 0x27, 0x12, 0xd5, 0x23, 0xfd, 0xf2, 0xa0, 0x39, 0x6a, 0xe5, 0x87, 0xa0, 0x93,
	0x7c, 0x0f, 0xe2, 0xfe, 0xcd, 0xbd, 0x48, 0xe4, 0xbe, 0xd0, 0x6b, 0x74, 0x93, 0xe3, 0xcb, 0xc4,
	0x18, 0xa1, 0xcd, 0x4d, 0xc0, 0x4e, 0x80, 0x6a, 0x77, 0xd0, 0xc7, 0xdd, 0xa1, 0x41, 0xeb, 0x18,
	0xa8, 0x76, 0x48, 0x1d, 0xe8, 0xcc, 0x3e, 0x9f, 0x76, 0x4b, 0xb8, 0x1a, 0x2f, 0xc7, 0xd7, 0x5d,
	0x62, 0xd9, 0xd0, 0xb8, 0xdf, 0x8c, 0xa2, 0xe1, 0xaa, 0x4f, 0x19, 0x0e, 0xfd, 0x9d, 0x25, 0xb1,
	0xea, 0xd5, 0x8c, 0x22, 0x1d, 0x58, 0x7f, 0x13, 0xa8, 0x9a, 0x7e, 0x0e, 0x1c, 0x49, 0x0a, 0x8e,
	0x7c, 0x0d, 0xf5, 0xbd, 0xd7, 0x74, 0x8b, 0xff, 0x32, 0xe3, 0x3d, 0xc8, 0xbe, 0x82, 0xfa, 0x4e,
	0x84, 0xd2, 0x0f, 0xd2, 0xbb, 0xdc, 0x32, 0x1d, 0x43, 0xbc, 0xca, 0xb3, 0xfc, 0x1e, 0x2f, 0x6a,
	0xa7, 0x4f, 0x69, 0x7f, 0xfe, 0xa5, 0xf8, 0x95, 0x00, 0x45, 0x73, 0x15, 0xd4, 0x93, 0xff, 0xab,
	0xfe, 0xe8, 0x09, 0xf5, 0x9f, 0x43, 0x75, 0x2d, 0xc3, 0x95, 0x48, 0xf2, 0x3e, 0x8b, 0xc6, 0xc8,
	0x31, 0xeb, 0x0f, 0x02, 0x6d, 0x3b, 0x59, 0x89, 0x84, 0x0b, 0xb5, 0x95, 0xb1, 0x12, 0x6c, 0x04,
	0xd4, 0x97, 0xab, 0xfd, 0xc5, 0x7c, 0x65, 0xaa, 0x0a, 0x14, 0x7d, 0x33, 0x33, 0x35, 0x91, 0x68,
	0x07, 0xe4, 0xb2, 0x1e, 0xd4, 0x56, 0x22, 0xf5, 0x82, 0x50, 0xe5, 0x06, 0xdb, 0x87, 0xd6, 0x8f,
	0x00, 0x0f, 0x6c, 0xf4, 0xb6, 0x73, 0x39, 0x99, 0x4c, 0x1d, 0xa7, 0x5b, 0x62, 0x0c, 0x3a, 0x97,
	0xf3, 0xf7, 0x73, 0x7b, 0x39, 0x77, 0xd1, 0xf0, 0x53, 0xde, 0x25, 0xec, 0x25, 0xb4, 0xe7, 0xf6,
	0xc2, 0x3d, 0xbc, 0x0f, 0x1d, 0x80, 0x25, 0xb7, 0xe7, 0xa7, 0xee, 0xe2, 0x92, 0xcf, 0xbb, 0x65,
	0xd6, 0x80, 0x8a, 0xbd, 0x98, 0xe9, 0x5b, 0xb0, 0x86, 0xba, 0x16, 0xe6, 0x88, 0xf4, 0x7e, 0x40,
	0x90, 0x83, 0x01, 0x71, 0x02, 0x55, 0x89, 0x38, 0xaa, 0x2a, 0x3f, 0xec, 0xaa, 0x69, 0x26, 0x87,
	0xd8, 0x09, 0xb4, 0x57, 0xe2, 0x26, 0xbb, 0x75, 0x23, 0xa1, 0x94, 0x77, 0x6b, 0x6e, 0x43, 0x83,
	0xb7, 0x74, 0xf2, 0xdc, 0xe4, 0xac, 0xdf, 0x09, 0x54, 0x74, 0x19, 0xeb, 0x03, 0x8d, 0xe4, 0x4e,
	0xe4, 0xe7, 0x94, 0x8f, 0x88, 0x73, 0xb9, 0x13, 0xb3, 0x12, 0xd7, 0x08, 0x3b, 0x81, 0x8a, 0xef,
	0xa5, 0xfe, 0xba, 0x68, 0xc4, 0x09, 0xa6, 0x66, 0x25, 0x6e, 0x30, 0xfc, 0xcc, 0x26, 0xf0, 0x37,
	0xc5, 0xb1, 0xf5, 0x3e, 0xf0, 0x37, 0xf8, 0x19, 0x44, 0x90, 0xf1, 0x53, 0x16, 0x6d, 0x8b, 0xf3,
	0xea, 0x5d, 0x16, 0x6d, 0x91, 0x81, 0xc8, 0xdb, 0x3a, 0x54, 0x3d, 0x5f, 0x3b, 0x69, 0x04, 0x14,
	0x25, 0x14, 0xfc, 0x41, 0xfe, 0xdb, 0x1f, 0x56, 0x0d, 0x2a, 0x5a, 0x13, 0x16, 0xe3, 0x8f, 0x9f,
	0x55, 0x3c, 0x02, 0x8a, 0x52, 0x9e, 0x53, 0x33, 0x92, 0x40, 0x71, 0xbe, 0xb3, 0xef, 0xa0, 0x81,
	0x6f, 0xda, 0x58, 0xcf, 0xaf, 0x97, 0x79, 0x5f, 0x0f, 0x8f, 0xdc, 0x31, 0xfb, 0xf8, 0x2d, 0x78,
	0x43, 0xd8, 0x37, 0x00, 0x8e, 0x88, 0x57, 0xb6, 0x39, 0xb4, 0xce, 0xc1, 0x49, 0x3a, 0x22, 0x3d,
	0xfe, 0xe4, 0x11, 0x9b, 0xde, 0x54, 0xf5, 0xeb, 0xf7, 0xed, 0x3f, 0x01, 0x00, 0x00, 0xff, 0xff,
	0x9d, 0xde, 0x3a, 0x5d, 0x69, 0x07, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// GameClient is the client API for Game service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type GameClient interface {
	// JoinATeam allows the player to listen the server during the match.
	JoinATeam(ctx context.Context, in *JoinRequest, opts ...grpc.CallOption) (Game_JoinATeamClient, error)
	// SendOrders allows the player to send others to the server when the game is on listening state.
	SendOrders(ctx context.Context, in *OrderSet, opts ...grpc.CallOption) (*OrderResponse, error)
}

type gameClient struct {
	cc grpc.ClientConnInterface
}

func NewGameClient(cc grpc.ClientConnInterface) GameClient {
	return &gameClient{cc}
}

func (c *gameClient) JoinATeam(ctx context.Context, in *JoinRequest, opts ...grpc.CallOption) (Game_JoinATeamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Game_serviceDesc.Streams[0], "/lugo.Game/JoinATeam", opts...)
	if err != nil {
		return nil, err
	}
	x := &gameJoinATeamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Game_JoinATeamClient interface {
	Recv() (*GameSnapshot, error)
	grpc.ClientStream
}

type gameJoinATeamClient struct {
	grpc.ClientStream
}

func (x *gameJoinATeamClient) Recv() (*GameSnapshot, error) {
	m := new(GameSnapshot)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *gameClient) SendOrders(ctx context.Context, in *OrderSet, opts ...grpc.CallOption) (*OrderResponse, error) {
	out := new(OrderResponse)
	err := c.cc.Invoke(ctx, "/lugo.Game/SendOrders", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GameServer is the server API for Game service.
type GameServer interface {
	// JoinATeam allows the player to listen the server during the match.
	JoinATeam(*JoinRequest, Game_JoinATeamServer) error
	// SendOrders allows the player to send others to the server when the game is on listening state.
	SendOrders(context.Context, *OrderSet) (*OrderResponse, error)
}

// UnimplementedGameServer can be embedded to have forward compatible implementations.
type UnimplementedGameServer struct {
}

func (*UnimplementedGameServer) JoinATeam(req *JoinRequest, srv Game_JoinATeamServer) error {
	return status.Errorf(codes.Unimplemented, "method JoinATeam not implemented")
}
func (*UnimplementedGameServer) SendOrders(ctx context.Context, req *OrderSet) (*OrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendOrders not implemented")
}

func RegisterGameServer(s *grpc.Server, srv GameServer) {
	s.RegisterService(&_Game_serviceDesc, srv)
}

func _Game_JoinATeam_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(JoinRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GameServer).JoinATeam(m, &gameJoinATeamServer{stream})
}

type Game_JoinATeamServer interface {
	Send(*GameSnapshot) error
	grpc.ServerStream
}

type gameJoinATeamServer struct {
	grpc.ServerStream
}

func (x *gameJoinATeamServer) Send(m *GameSnapshot) error {
	return x.ServerStream.SendMsg(m)
}

func _Game_SendOrders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OrderSet)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GameServer).SendOrders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lugo.Game/SendOrders",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GameServer).SendOrders(ctx, req.(*OrderSet))
	}
	return interceptor(ctx, in, info, handler)
}

var _Game_serviceDesc = grpc.ServiceDesc{
	ServiceName: "lugo.Game",
	HandlerType: (*GameServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SendOrders",
			Handler:    _Game_SendOrders_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "JoinATeam",
			Handler:       _Game_JoinATeam_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "server.proto",
}
